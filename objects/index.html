<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Objects - The Rust FFI Omnibus</title>
  <meta name="description" content="A collection of examples of using Rust from other languages such as C, Ruby, or Python.
">

  <link rel="stylesheet" href="/rust-ffi-omnibus/css/main.css">
  <link rel="canonical" href="http://jakegoulding.com/rust-ffi-omnibus/objects/">
  <link rel="alternate" type="application/rss+xml" title="The Rust FFI Omnibus" href="http://jakegoulding.com/rust-ffi-omnibus/feed.xml" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/github-gist.min.css">
  <script src="/rust-ffi-omnibus/script/main.js"></script>
</head>


  <body class="site">

    <header class="site-header">

  <a class="site-header-title" href="/rust-ffi-omnibus/">The Rust FFI Omnibus</a>

</header>


    <div class="site-content content">
      <main class="content-content">
        <h1 id="using-rust-objects-from-other-languages">Using Rust objects from other languages</h1>

<p>Let’s create a Rust object that will tell us how many people live in
each USA ZIP code. We want to be able to use this logic in other
languages, but we only need to pass simple primitives like integers or
strings across the FFI boundary. The object will have both mutable and
immutable methods. Because we can not look inside the object, this is
often referred to as an <em>opaque object</em> or an <em>opaque pointer</em>.</p>

<pre><code class="rust">extern crate libc;

use libc::c_char;
use std::collections::HashMap;
use std::ffi::CStr;

pub struct ZipCodeDatabase {
    population: HashMap&lt;String, u32&gt;,
}

impl ZipCodeDatabase {
    fn new() -&gt; ZipCodeDatabase {
        ZipCodeDatabase {
            population: HashMap::new(),
        }
    }

    fn populate(&amp;mut self) {
        for i in 0..100_000 {
            let zip = format!(&quot;{:05}&quot;, i);
            self.population.insert(zip, i);
        }
    }

    fn population_of(&amp;self, zip: &amp;str) -&gt; u32 {
        self.population.get(zip).cloned().unwrap_or(0)
    }
}

#[no_mangle]
pub extern &quot;C&quot; fn zip_code_database_new() -&gt; *mut ZipCodeDatabase {
    Box::into_raw(Box::new(ZipCodeDatabase::new()))
}

#[no_mangle]
pub extern &quot;C&quot; fn zip_code_database_free(ptr: *mut ZipCodeDatabase) {
    if ptr.is_null() {
        return;
    }
    unsafe {
        Box::from_raw(ptr);
    }
}

#[no_mangle]
pub extern &quot;C&quot; fn zip_code_database_populate(ptr: *mut ZipCodeDatabase) {
    let database = unsafe {
        assert!(!ptr.is_null());
        &amp;mut *ptr
    };
    database.populate();
}

#[no_mangle]
pub extern &quot;C&quot; fn zip_code_database_population_of(
    ptr: *const ZipCodeDatabase,
    zip: *const c_char,
) -&gt; u32 {
    let database = unsafe {
        assert!(!ptr.is_null());
        &amp;*ptr
    };
    let zip = unsafe {
        assert!(!zip.is_null());
        CStr::from_ptr(zip)
    };
    let zip_str = zip.to_str().unwrap();
    database.population_of(zip_str)
}
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">struct</code> is defined in a normal way for Rust. One <code class="language-plaintext highlighter-rouge">extern</code>
function is created for each function of the object. C has no
built-in namespacing concept, so it is normal to prefix each function
with a package name and/or a type name. For this example, we use
<code class="language-plaintext highlighter-rouge">zip_code_database</code>. Following normal C conventions, a pointer to the
object is always provided as the first argument.</p>

<p>To create a new instance of object, we box the result of the object’s
constructor. This places the struct onto the heap where it will have a
stable memory address. This address is converted into a raw pointer
using <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw"><code class="language-plaintext highlighter-rouge">Box::into_raw</code></a>.</p>

<p>This pointer points at memory allocated by Rust; memory allocated by
Rust <strong>must</strong> be deallocated by Rust. We use
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw"><code class="language-plaintext highlighter-rouge">Box::from_raw</code></a> to convert the pointer back into a
<code class="language-plaintext highlighter-rouge">Box&lt;ZipCodeDatabase&gt;</code> when the object is to be freed. Unlike other
functions, we <em>do</em> allow <code class="language-plaintext highlighter-rouge">NULL</code> to be passed, but simply do nothing
in that case. This is a nicety for client programmers.</p>

<p>To create a reference from a raw pointer, you can use the terse syntax
<code class="language-plaintext highlighter-rouge">&amp;*</code>, which indicates that the pointer should be dereferenced and then
re-referenced. Creating a mutable reference is similar, but uses
<code class="language-plaintext highlighter-rouge">&amp;mut *</code>. Like other pointers, you must ensure that the pointer is not
<code class="language-plaintext highlighter-rouge">NULL</code>.</p>

<p>Note that a <code class="language-plaintext highlighter-rouge">*const T</code> can be freely converted to and from a <code class="language-plaintext highlighter-rouge">*mut T</code>
and that nothing prevents the client code from never calling the
deallocation function, or from calling it more than once. Memory
management and safety guarantees are completely in the hands of the
programmer.</p>

<h2 id="c">C</h2>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;

typedef struct zip_code_database zip_code_database_t;

extern zip_code_database_t *
zip_code_database_new(void);

extern void
zip_code_database_free(zip_code_database_t *);

extern void
zip_code_database_populate(zip_code_database_t *);

extern uint32_t
zip_code_database_population_of(const zip_code_database_t *, const char *zip);

int main(void) {
  zip_code_database_t *database = zip_code_database_new();
  zip_code_database_populate(database);

  uint32_t pop1 = zip_code_database_population_of(database, &quot;90210&quot;);
  uint32_t pop2 = zip_code_database_population_of(database, &quot;20500&quot;);

  zip_code_database_free(database);

  printf(&quot;%&quot; PRId32 &quot;\n&quot;, (int32_t)pop1 - (int32_t)pop2);
}
</code></pre>

<p>A dummy struct is created to provide a small amount of type-safety.</p>

<p>The <code class="language-plaintext highlighter-rouge">const</code> modifier is used on functions where appropriate, even
though const-correctness is much more fluid in C than in Rust.</p>

<h2 id="ruby">Ruby</h2>

<pre><code class="ruby">require &#39;ffi&#39;

class ZipCodeDatabase &lt; FFI::AutoPointer
  def self.release(ptr)
    Binding.free(ptr)
  end

  def populate
    Binding.populate(self)
  end

  def population_of(zip)
    Binding.population_of(self, zip)
  end

  module Binding
    extend FFI::Library
    ffi_lib &#39;objects&#39;

    attach_function :new, :zip_code_database_new,
                    [], ZipCodeDatabase
    attach_function :free, :zip_code_database_free,
                    [ZipCodeDatabase], :void
    attach_function :populate, :zip_code_database_populate,
                    [ZipCodeDatabase], :void
    attach_function :population_of, :zip_code_database_population_of,
                    [ZipCodeDatabase, :string], :uint32
  end
end

database = ZipCodeDatabase::Binding.new

database.populate
pop1 = database.population_of(&quot;90210&quot;)
pop2 = database.population_of(&quot;20500&quot;)

puts pop1 - pop2
</code></pre>

<p>To wrap the raw functions, we create a small class inheriting from
<a href="http://www.rubydoc.info/github/ffi/ffi/FFI/AutoPointer"><code class="language-plaintext highlighter-rouge">AutoPointer</code></a>. <code class="language-plaintext highlighter-rouge">AutoPointer</code> will ensure that the
underlying resource is freed when the object is freed. To do this, the
user must define the <code class="language-plaintext highlighter-rouge">self.release</code> method.</p>

<p>Unfortunately, because we inherit from <code class="language-plaintext highlighter-rouge">AutoPointer</code>, we cannot
redefine the initializer. To better group concepts together, we bind
the FFI methods in a nested module. We provide shorter names for the
bound methods, which enables the client to just call
<code class="language-plaintext highlighter-rouge">ZipCodeDatabase::Binding.new</code>.</p>

<h2 id="python">Python</h2>

<pre><code class="python">#!/usr/bin/env python3

import sys, ctypes
from ctypes import c_char_p, c_uint32, Structure, POINTER

class ZipCodeDatabaseS(Structure):
    pass

prefix = {&#39;win32&#39;: &#39;&#39;}.get(sys.platform, &#39;lib&#39;)
extension = {&#39;darwin&#39;: &#39;.dylib&#39;, &#39;win32&#39;: &#39;.dll&#39;}.get(sys.platform, &#39;.so&#39;)
lib = ctypes.cdll.LoadLibrary(prefix + &quot;objects&quot; + extension)

lib.zip_code_database_new.restype = POINTER(ZipCodeDatabaseS)

lib.zip_code_database_free.argtypes = (POINTER(ZipCodeDatabaseS), )

lib.zip_code_database_populate.argtypes = (POINTER(ZipCodeDatabaseS), )

lib.zip_code_database_population_of.argtypes = (POINTER(ZipCodeDatabaseS), c_char_p)
lib.zip_code_database_population_of.restype = c_uint32

class ZipCodeDatabase:
    def __init__(self):
        self.obj = lib.zip_code_database_new()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        lib.zip_code_database_free(self.obj)

    def populate(self):
        lib.zip_code_database_populate(self.obj)

    def population_of(self, zip):
        return lib.zip_code_database_population_of(self.obj, zip.encode(&#39;utf-8&#39;))

with ZipCodeDatabase() as database:
    database.populate()
    pop1 = database.population_of(&quot;90210&quot;)
    pop2 = database.population_of(&quot;20500&quot;)
    print(pop1 - pop2)
</code></pre>

<p>We create an empty structure to represent our type. This will only be
used in conjunction with the <code class="language-plaintext highlighter-rouge">POINTER</code> method, which creates a new
type as a pointer to an existing one.</p>

<p>To ensure that memory is properly cleaned up, we use a <em>context
manager</em>. This is tied to our class through the <code class="language-plaintext highlighter-rouge">__enter__</code> and
<code class="language-plaintext highlighter-rouge">__exit__</code> methods. We use the <code class="language-plaintext highlighter-rouge">with</code> statement to start a new
context. When the context is over, the <code class="language-plaintext highlighter-rouge">__exit__</code> method will be
automatically called, preventing the memory leak.</p>

<h2 id="haskell">Haskell</h2>

<pre><code class="haskell">{-# LANGUAGE ForeignFunctionInterface #-}

import Data.Word (Word32)
import Foreign.Ptr
import Foreign.ForeignPtr
import Foreign.C.String (CString(..), newCString)

data ZipCodeDatabase

foreign import ccall unsafe &quot;zip_code_database_new&quot;
  zip_code_database_new :: IO (Ptr ZipCodeDatabase)

foreign import ccall unsafe &quot;&amp;zip_code_database_free&quot;
  zip_code_database_free :: FunPtr (Ptr ZipCodeDatabase -&gt; IO ())

foreign import ccall unsafe &quot;zip_code_database_populate&quot;
  zip_code_database_populate :: Ptr ZipCodeDatabase -&gt; IO ()

foreign import ccall unsafe &quot;zip_code_database_population_of&quot;
  zip_code_database_population_of :: Ptr ZipCodeDatabase -&gt; CString -&gt; Word32

createDatabase :: IO (Maybe (ForeignPtr ZipCodeDatabase))
createDatabase = do
  ptr &lt;- zip_code_database_new
  if ptr /= nullPtr
    then do
      foreignPtr &lt;- newForeignPtr zip_code_database_free ptr
      return $ Just foreignPtr
    else
      return Nothing

populate = zip_code_database_populate

populationOf :: Ptr ZipCodeDatabase -&gt; String -&gt; IO (Word32)
populationOf db zip = do
  zip_str &lt;- newCString zip
  return $ zip_code_database_population_of db zip_str

main :: IO ()
main = do
  db &lt;- createDatabase
  case db of
    Nothing -&gt; putStrLn &quot;Unable to create database&quot;
    Just ptr -&gt; withForeignPtr ptr $ \database -&gt; do
        populate database
        pop1 &lt;- populationOf database &quot;90210&quot;
        pop2 &lt;- populationOf database &quot;20500&quot;
        print (pop1 - pop2)
</code></pre>

<p>We start by defining an empty type to refer to the opaque object. When
defining the imported functions, we use the <code class="language-plaintext highlighter-rouge">Ptr</code> type constructor
with this new type as the type of the pointer returned from Rust. We
also use <code class="language-plaintext highlighter-rouge">IO</code> as allocating, freeing, and populating the object are
all functions with side-effects.</p>

<p>As allocation can theoretically fail, we check for <code class="language-plaintext highlighter-rouge">NULL</code> and return a
<code class="language-plaintext highlighter-rouge">Maybe</code> from the constructor. This is likely overkill, as Rust
currently aborts the process when the allocator fails.</p>

<p>To ensure that the allocated memory is automatically freed, we use the
<code class="language-plaintext highlighter-rouge">ForeignPtr</code> type. This takes a raw <code class="language-plaintext highlighter-rouge">Ptr</code> and a function to call when
the wrapped pointer is deallocated.</p>

<p>When using the wrapped pointer, <code class="language-plaintext highlighter-rouge">withForeignPtr</code> is used to unwrap it
before passing it back to the FFI functions.</p>

<h2 id="nodejs">Node.js</h2>

<pre><code class="javascript">const ffi = require(&#39;ffi-napi&#39;);

const lib = ffi.Library(&#39;libobjects&#39;, {
  zip_code_database_new: [&#39;pointer&#39;, []],
  zip_code_database_free: [&#39;void&#39;, [&#39;pointer&#39;]],
  zip_code_database_populate: [&#39;void&#39;, [&#39;pointer&#39;]],
  zip_code_database_population_of: [&#39;uint32&#39;, [&#39;pointer&#39;, &#39;string&#39;]],
});

const ZipCodeDatabase = function() {
  this.ptr = lib.zip_code_database_new();
};

ZipCodeDatabase.prototype.free = function() {
  lib.zip_code_database_free(this.ptr);
};

ZipCodeDatabase.prototype.populate = function() {
  lib.zip_code_database_populate(this.ptr);
};

ZipCodeDatabase.prototype.populationOf = function(zip) {
  return lib.zip_code_database_population_of(this.ptr, zip);
};

const database = new ZipCodeDatabase();
try {
  database.populate();
  const pop1 = database.populationOf(&#39;90210&#39;);
  const pop2 = database.populationOf(&#39;20500&#39;);
  console.log(pop1 - pop2);
} finally {
  database.free();
}
</code></pre>

<p>When importing the functions, we simply declare that a <code class="language-plaintext highlighter-rouge">pointer</code> type
is returned or accepted.</p>

<p>To make accessing the functions cleaner, we create a simple class that
maintains the pointer for us and abstracts passing it to the
lower-level functions. This also gives us as opportunity to rename the
functions with idiomatic JavaScript camel-case.</p>

<p>To ensure that the resources are cleaned up, we use a <code class="language-plaintext highlighter-rouge">try</code> block and
call the deallocation method in the <code class="language-plaintext highlighter-rouge">finally</code> block.</p>

<h2 id="c-1">C#</h2>

<pre><code class="csharp">using System;
using System.Runtime.InteropServices;

internal class Native
{
    [DllImport(&quot;objects&quot;)]
    internal static extern ZipCodeDatabaseHandle zip_code_database_new();
    [DllImport(&quot;objects&quot;)]
    internal static extern void zip_code_database_free(IntPtr db);
    [DllImport(&quot;objects&quot;)]
    internal static extern void zip_code_database_populate(ZipCodeDatabaseHandle db);
    [DllImport(&quot;objects&quot;)]
    internal static extern uint zip_code_database_population_of(ZipCodeDatabaseHandle db, string zip);
}

internal class ZipCodeDatabaseHandle : SafeHandle
{
    public ZipCodeDatabaseHandle() : base(IntPtr.Zero, true) {}

    public override bool IsInvalid
    {
        get { return this.handle == IntPtr.Zero; }
    }

    protected override bool ReleaseHandle()
    {
        if (!this.IsInvalid)
        {
            Native.zip_code_database_free(handle);
        }

        return true;
    }
}

public class ZipCodeDatabase : IDisposable
{
    private ZipCodeDatabaseHandle db;

    public ZipCodeDatabase()
    {
        db = Native.zip_code_database_new();
    }

    public void Populate()
    {
        Native.zip_code_database_populate(db);
    }

    public uint PopulationOf(string zip)
    {
        return Native.zip_code_database_population_of(db, zip);
    }

    public void Dispose()
    {
        db.Dispose();
    }

    static public void Main()
    {
        var db = new ZipCodeDatabase();
        db.Populate();

        var pop1 = db.PopulationOf(&quot;90210&quot;);
        var pop2 = db.PopulationOf(&quot;20500&quot;);

        Console.WriteLine(&quot;{0}&quot;, pop1 - pop2);
    }
}
</code></pre>

<p>As the responsibilities for calling the native functions are going to
be more spread out, we create a <code class="language-plaintext highlighter-rouge">Native</code> class to hold all the
definitions.</p>

<p>To ensure that the allocated memory is automatically freed, we create
a subclass of the <a href="https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.safehandle(v=vs.110).aspx"><code class="language-plaintext highlighter-rouge">SafeHandle</code></a> class. This requires
implementing <code class="language-plaintext highlighter-rouge">IsInvalid</code> and <code class="language-plaintext highlighter-rouge">ReleaseHandle</code>. Since our Rust function
accepts freeing a <code class="language-plaintext highlighter-rouge">NULL</code> pointer, we can say that every pointer is
valid.</p>

<p>We can use our safe wrapper <code class="language-plaintext highlighter-rouge">ZipCodeDatabaseHandle</code> as the type of the
FFI functions except for the free function. The actual pointer will be
automatically marshalled to and from the wrapper.</p>

<p>We also allow the <code class="language-plaintext highlighter-rouge">ZipCodeDatabase</code> to participate in the
<code class="language-plaintext highlighter-rouge">IDisposable</code> protocol, forwarding to the safe wrapper.</p>

<h2 id="julia">Julia</h2>

<pre><code class="">#!/usr/bin/env julia
using Libdl

libname = &quot;objects&quot;
if !Sys.iswindows()
    libname = &quot;lib$(libname)&quot;
end

lib = Libdl.dlopen(libname)

zipcodedatabase_new_sym = Libdl.dlsym(lib, :zip_code_database_new)
zipcodedatabase_free_sym = Libdl.dlsym(lib, :zip_code_database_free)
zipcodedatabase_populate_sym = Libdl.dlsym(lib, :zip_code_database_populate)
zipcodedatabase_populationof_sym = Libdl.dlsym(lib, :zip_code_database_population_of)

struct ZipCodeDatabase
    handle::Ptr{Nothing}

    function ZipCodeDatabase()
        handle = ccall(zipcodedatabase_new_sym, Ptr{Cvoid}, ())
        new(handle)
    end

    function ZipCodeDatabase(f::Function)
        database = ZipCodeDatabase()
        out = f(database)
        close(database)
        out
    end
end

close(database:: ZipCodeDatabase) = ccall(
    zipcodedatabase_free_sym,
    Cvoid, (Ptr{Cvoid},),
    database.handle
)

populate!(database:: ZipCodeDatabase) = ccall(
    zipcodedatabase_populate_sym,
    Cvoid, (Ptr{Cvoid},),
    database.handle
)

populationof(database:: ZipCodeDatabase, zipcode:: AbstractString) = ccall(
    zipcodedatabase_populationof_sym,
    UInt32, (Ptr{Cvoid}, Cstring),
    database.handle, zipcode
)

ZipCodeDatabase() do database
    populate!(database)
    pop1 = populationof(database, &quot;90210&quot;)
    pop2 = populationof(database, &quot;20500&quot;)
    println(pop1 - pop2)
end
</code></pre>

<p>As in other languages, we hide a handler pointer behind a new data type. The method which populates the database is called <code class="language-plaintext highlighter-rouge">populate!</code> to follow the Julia convention of having the <code class="language-plaintext highlighter-rouge">!</code> suffix on methods which modify the value.</p>

<p>There is currently no consensus on how Julia should handle native 
resources. While the inner constructor pattern for allocating the 
<code class="language-plaintext highlighter-rouge">ZipCodeDatabase</code> is suitable here, we can think of many ways to let
Julia free it afterwards. In this example, we show two means of freeing 
the object: (1) a mapping constructor for use with the <code class="language-plaintext highlighter-rouge">do</code> syntax, and
(2) a <code class="language-plaintext highlighter-rouge">close</code> overload for manually freeing the object.</p>

<p>The inner constructor <code class="language-plaintext highlighter-rouge">ZipCodeDatabase(f)</code>, is both in charge of
creating and freeing the object. With the <code class="language-plaintext highlighter-rouge">do</code> syntax, the user code
becomes similar to one using Python’s <code class="language-plaintext highlighter-rouge">with</code> syntax. Alternatively,
the programmer can use the other constructor and call the method
<code class="language-plaintext highlighter-rouge">close</code> when it is no longer needed.</p>

      </main>

      <nav class="content-navigation">
        <ul>
          
            <li><a href="/rust-ffi-omnibus/">Index</a></li>
          
            <li><a href="/rust-ffi-omnibus/basics/">Basics</a></li>
          
            <li><a href="/rust-ffi-omnibus/integers/">Integers</a></li>
          
            <li><a href="/rust-ffi-omnibus/string_arguments/">String Arguments</a></li>
          
            <li><a href="/rust-ffi-omnibus/string_return/">String Return Values</a></li>
          
            <li><a href="/rust-ffi-omnibus/slice_arguments/">Slice Arguments</a></li>
          
            <li><a href="/rust-ffi-omnibus/tuples/">Tuples</a></li>
          
            <li><a href="/rust-ffi-omnibus/objects/">Objects</a></li>
          
            <li><a href="/rust-ffi-omnibus/contributors/">Contributors</a></li>
          
        </ul>
      </nav>
    </div>

    <footer class="site-footer">

  <div class="footer-meta">
    <ul class="footer-meta-social-media">
      <li>
        <a href="https://github.com/shepmaster/rust-ffi-omnibus">
          <span class="icon  icon--github">
            <svg viewBox="0 0 16 16">
              <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
            </svg>
          </span>

          <span class="username">rust-ffi-omnibus</span>
        </a>
      </li>

      
      <li>
        <a href="https://twitter.com/jakegoulding">
          <span class="icon  icon--twitter">
            <svg viewBox="0 0 16 16">
              <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                                      c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
            </svg>
          </span>

          <span class="username">jakegoulding</span>
        </a>
      </li>
      
    </ul>

    <p class="footer-meta-description">A collection of examples of using Rust from other languages such as C, Ruby, or Python.
</p>
  </div>

  <div class="footer-license">
    <div class="footer-license-text">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
        <img alt="Creative Commons License" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" />
      </a>
      The Rust FFI Omnibus is licensed under a
      <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
        Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
      </a>
      The source code is licensed under the
      <a rel="license" href="http://opensource.org/licenses/MIT">
        MIT License.
      </a>
    </div>
  </div>

</footer>


  </body>

  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/highlight.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/languages/rust.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/languages/haskell.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-20521797-2', 'auto');
    ga('send', 'pageview');

  </script>
  
</html>
